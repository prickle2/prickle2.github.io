<script>
  // 순환 문구
  const seq = ["세상을 배움으로 채우는","도전을 두려워하지 않는","작은 것에도 감사하는"];
  const kw  = document.getElementById('kw');

  // 가장 긴 문구(기준): 이게 한 줄에 들어가도록 폰트 크기 계산 → 고정
  const LONGEST = "세상을 배움으로 채우는";

  function calcFitFontPx(container, text, {min=20, max=64} = {}){
    // 측정용 엘리먼트 생성
    const probe = document.createElement('span');
    probe.style.visibility = 'hidden';
    probe.style.position = 'absolute';
    probe.style.whiteSpace = 'nowrap';
    probe.style.lineHeight = '1.08';
    probe.style.fontFamily = getComputedStyle(container).fontFamily;
    probe.style.fontWeight = getComputedStyle(container).fontWeight;
    probe.textContent = text;
    container.parentNode.appendChild(probe);

    // 이진 탐색으로 한 줄에 들어가는 최대 폰트 크기 찾기
    let lo = min, hi = max, ans = min;
    const maxWidth = container.clientWidth; // 같은 라인/레이아웃에서 측정
    while (lo <= hi){
      const mid = Math.floor((lo+hi)/2);
      probe.style.fontSize = mid + 'px';
      if (probe.offsetWidth <= maxWidth){
        ans = mid; lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }
    probe.remove();
    return ans;
  }

  // 초기 한 번 + 리사이즈 시 재산정(한 줄 조건을 지키기 위함)
  function applyFixedFont(){
    const px = calcFitFontPx(kw, LONGEST, {min:20, max:64});
    document.querySelectorAll('.headline-line').forEach(el => {
      el.style.fontSize = px + 'px'; // 모두 동일 크기 고정
    });
  }
  window.addEventListener('resize', applyFixedFont);
  applyFixedFont();

  // 문구 순환(폰트 크기는 변경하지 않음!)
  let i = 0;
  setInterval(()=>{
    i = (i+1) % seq.length;
    kw.style.transition = "opacity .22s, transform .22s";
    kw.style.opacity = 0; kw.style.transform = "translateY(-4px)";
    setTimeout(()=>{
      kw.textContent = seq[i];
      kw.style.opacity = 1; kw.style.transform = "none";
      // 크기는 이미 고정, 재계산 불필요
    }, 200);
  }, 2600);
</script>
